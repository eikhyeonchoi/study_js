/**
 * ㅡㅡ핵심키워드
 * 전역변수의 문제점
 * 
 * ㅡㅡ개요
 * 전역변수는 가급적 사용하지 말것
 */

// 앞서 선언문들은 모두 실행컨텍스트가 평가할때 실행한다 했지만
// 그 선언문들은 모두 전역변수에 해당하는 선언문들이다
// 지역변수 x는 함수가 끝나면 메모리가 소멸됨
// 즉 foo()의 x는 함수가 끝나면 소멸됨
function foo() {
    var x = 1;
    return x;
}

// 출력값은 무엇일까
// 호이스팅은 스코프단위로 작동한다
// 즉 var x;가 런타임 이전 수행되고 undefined로 초기화된다
// 그 후 console.log()를 실행하고
// 그 다음 x = 'local'을 수행하기때문에
// 결과값은 undefined이다
var x = 'global';
function foo() {
    console.log(x);
    var x = 'local';
}
foo(); // ??

// 전역변수의 생명주기
// 일단 전역변수는 더이상 수행할 코드가 없을때 소멸됨
// var 키워드로 선언한 전역변수는 전역객체의 프로퍼티가됨
// 즉 window의 프로퍼티가 됨
// 아래의 x는 window.x와 동일하다
// 바꿔말하면 전역변수의 생명주기는 전역객체와 동일하다
var x = 10; 

// 문제점 
// 1. 암묵적결합: 모든곳에서 사용가능하다 변수의 유효범위를 줄여야함(순수함수 권장)
// 2. 긴 생명주기: 말 그대로 주기가 길다 
// 3. 전역스코프임: 전역 스코프라는 말인 즉슨 식별자결정(검색)이 느리다는것을 의미함
// 4. 네임스페이스오염: 이게 파일이 수십개가되면 window객체를 공유하기때문에
//                     자칫 잘못하다가 파일간 변수명이 겹쳐버리면 골치아픔

// 억제방법
// 1. 즉시실행함수 사용
// 2. 모듈패턴(즉시실행함수 응용)
var counter = (function() {
    var num = 0;
    return {
        increase: function() {
            return num++;
        },
        decrease() { // ES6 함수축약
            return num--;
        }
    };
}());